"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const multer_1 = __importDefault(require("multer"));
const s3_1 = __importDefault(require("../lib/s3"));
const prisma_1 = __importDefault(require("../lib/prisma"));
const uuid_1 = require("uuid");
const router = express_1.default.Router();
const upload = (0, multer_1.default)({ storage: multer_1.default.memoryStorage() });
// üî† –ì–µ–Ω–µ—Ä–∞—Ü–∏—è slug
function slugify(text) {
    return text
        .toLowerCase()
        .trim()
        .replace(/[\s_]+/g, "-")
        .replace(/[^\w\-–∞-—è—ë]/gi, "")
        .replace(/--+/g, "-")
        .replace(/^-+|-+$/g, "")
        .replace(/—ë/g, "e")
        .replace(/–∞/g, "a")
        .replace(/–±/g, "b")
        .replace(/–≤/g, "v")
        .replace(/–≥/g, "g")
        .replace(/–¥/g, "d")
        .replace(/–µ/g, "e")
        .replace(/–∂/g, "zh")
        .replace(/–∑/g, "z")
        .replace(/–∏/g, "i")
        .replace(/–π/g, "y")
        .replace(/–∫/g, "k")
        .replace(/–ª/g, "l")
        .replace(/–º/g, "m")
        .replace(/–Ω/g, "n")
        .replace(/–æ/g, "o")
        .replace(/–ø/g, "p")
        .replace(/—Ä/g, "r")
        .replace(/—Å/g, "s")
        .replace(/—Ç/g, "t")
        .replace(/—É/g, "u")
        .replace(/—Ñ/g, "f")
        .replace(/—Ö/g, "h")
        .replace(/—Ü/g, "c")
        .replace(/—á/g, "ch")
        .replace(/—à/g, "sh")
        .replace(/—â/g, "sch")
        .replace(/—ä/g, "")
        .replace(/—ã/g, "y")
        .replace(/—å/g, "")
        .replace(/—ç/g, "e")
        .replace(/—é/g, "yu")
        .replace(/—è/g, "ya");
}
// ‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —É—Å–ª—É–≥–∏
router.post("/add", upload.single("image"), async (req, res) => {
    try {
        const { title, description, price, days, adminId, keywords, } = req.body;
        const options = JSON.parse(req.body.options || "[]"); // features
        const benefits = JSON.parse(req.body.benefits || "[]");
        const purposes = JSON.parse(req.body.purposes || "[]");
        const file = req.file;
        if (!file) {
            return res.status(400).json({ success: false, message: "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ" });
        }
        const extension = file.originalname.split(".").pop();
        const key = `services/${(0, uuid_1.v4)()}.${extension}`;
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ S3
        await s3_1.default.putObject({
            Bucket: process.env.AWS_BUCKET_NAME,
            Key: key,
            Body: file.buffer,
            ContentType: file.mimetype,
            ACL: "public-read",
        }).promise();
        const imageUrl = `${process.env.S3_ENDPOINT}/${key}`;
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è slug
        const slug = title.toLowerCase()
            .replace(/[^a-z–∞-—è0-9]+/gi, "-")
            .replace(/^-+|-+$/g, "")
            .replace(/--+/g, "-");
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —É—Å–ª—É–≥—É –∏ —Å–≤—è–∑–∏
        const service = await prisma_1.default.service.create({
            data: {
                title,
                slug,
                description,
                price: parseFloat(price),
                days: parseInt(days),
                imageUrl,
                keywords,
                features: {
                    create: options.map((name) => ({ name })),
                },
                benefits: {
                    create: benefits.map((text) => ({ text })),
                },
                purposes: {
                    create: purposes.map((p) => ({
                        action: p.action,
                        detail: p.detail,
                    })),
                },
            },
            include: {
                features: true,
                benefits: true,
                purposes: true,
            },
        });
        return res.status(200).json({ success: true, service });
    }
    catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏:", error);
        return res.status(500).json({ success: false, message: "–û—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ" });
    }
});
// ‚úèÔ∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ª—É–≥–∏
router.put("/edit/:id", upload.single("image"), async (req, res) => {
    try {
        const id = req.params.id;
        const { title, description, price, days, keywords } = req.body;
        const features = JSON.parse(req.body.features || "[]");
        const benefits = JSON.parse(req.body.benefits || "[]");
        const purposes = JSON.parse(req.body.purposes || "[]");
        const existing = await prisma_1.default.service.findUnique({
            where: { id },
            include: { features: true, benefits: true, purposes: true },
        });
        if (!existing) {
            return res.status(404).json({ success: false, message: "–£—Å–ª—É–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
        }
        let imageUrl = existing.imageUrl;
        if (req.file) {
            // –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            if (existing.imageUrl) {
                const oldKey = existing.imageUrl.split(`/${process.env.AWS_BUCKET_NAME}/`)[1];
                if (oldKey) {
                    await s3_1.default.deleteObject({
                        Bucket: process.env.AWS_BUCKET_NAME,
                        Key: oldKey,
                    }).promise();
                }
            }
            const newKey = `services/${(0, uuid_1.v4)()}-${req.file.originalname}`;
            await s3_1.default.putObject({
                Bucket: process.env.AWS_BUCKET_NAME,
                Key: newKey,
                Body: req.file.buffer,
                ContentType: req.file.mimetype,
                ACL: "public-read",
            }).promise();
            imageUrl = `${process.env.AWS_S3_ENDPOINT}/${process.env.AWS_BUCKET_NAME}/${newKey}`;
        }
        // –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ —Ñ–∏—á–∏, –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –∏ —Ü–µ–ª–∏
        await prisma_1.default.serviceFeature.deleteMany({ where: { serviceId: id } });
        await prisma_1.default.serviceBenefit.deleteMany({ where: { serviceId: id } });
        await prisma_1.default.servicePurpose.deleteMany({ where: { serviceId: id } });
        const slug = slugify(title);
        const updated = await prisma_1.default.service.update({
            where: { id },
            data: {
                title,
                slug,
                description,
                price: parseFloat(price),
                days: parseInt(days),
                imageUrl,
                keywords,
                features: {
                    create: features.map((f) => ({ name: f.name })),
                },
                benefits: {
                    create: benefits.map((text) => ({ text })),
                },
                purposes: {
                    create: purposes.map((p) => ({
                        action: p.action,
                        detail: p.detail,
                    })),
                },
            },
            include: { features: true, benefits: true, purposes: true },
        });
        res.json({ success: true, service: updated });
    }
    catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏:", error);
        res.status(500).json({ success: false, message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏" });
    }
});
// üì• –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —É—Å–ª—É–≥
router.get("/", async (req, res) => {
    try {
        const services = await prisma_1.default.service.findMany({
            include: { features: true, benefits: true, purposes: true },
            orderBy: { createdAt: "desc" },
        });
        res.json({ success: true, services });
    }
    catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —É—Å–ª—É–≥:", error);
        res.status(500).json({ success: false, message: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
});
// üìÑ –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π —É—Å–ª—É–≥–∏ –ø–æ slug
router.get("/:slug", async (req, res) => {
    try {
        const { slug } = req.params;
        const service = await prisma_1.default.service.findFirst({
            where: { slug },
            include: { features: true, benefits: true, purposes: true },
        });
        if (!service) {
            return res.status(404).json({ success: false, message: "–£—Å–ª—É–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
        }
        res.json({ success: true, service });
    }
    catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏:", error);
        res.status(500).json({ success: false, message: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
});
// üóë –£–¥–∞–ª–µ–Ω–∏–µ —É—Å–ª—É–≥–∏
router.delete("/delete/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const service = await prisma_1.default.service.findUnique({
            where: { id },
        });
        if (!service) {
            return res.status(404).json({ success: false, message: "–£—Å–ª—É–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
        }
        // –£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ S3
        if (service.imageUrl) {
            const key = service.imageUrl.split(`/${process.env.AWS_BUCKET_NAME}/`)[1];
            if (key) {
                await s3_1.default.deleteObject({
                    Bucket: process.env.AWS_BUCKET_NAME,
                    Key: key,
                }).promise();
            }
        }
        // –£–¥–∞–ª–∏—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏
        await prisma_1.default.serviceFeature.deleteMany({ where: { serviceId: id } });
        await prisma_1.default.serviceBenefit.deleteMany({ where: { serviceId: id } });
        await prisma_1.default.servicePurpose.deleteMany({ where: { serviceId: id } });
        // –£–¥–∞–ª–∏—Ç—å —Å–∞–º—É —É—Å–ª—É–≥—É
        await prisma_1.default.service.delete({
            where: { id },
        });
        res.json({ success: true });
    }
    catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏:", error);
        res.status(500).json({ success: false, message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏" });
    }
});
exports.default = router;
